## 爬楼梯（T70）

### 问题描述

**n**阶台阶，每次爬1级或2级，有多少种爬法？



### 问题解读

假设解决问题的函数是`f()`，输入楼梯数`n`，即可得到爬楼梯方案数答案：`f(n)`。

一个事实是完成爬完n阶台阶的前一个状态有两种：

1）最后一次采取爬1阶：即此前爬了n-1阶，这n-1阶又有`f(n-1)`种爬法

2）最后一次采取爬2阶：即此前爬了n-2阶，这n-2阶又有`f(n-2)`种爬法

综上可以得出一个事实是：爬完n阶的总方法数可以根据最后一次爬楼梯的阶数理解为两部分相加而成。根据之前的函数假设，可以表达为下列式子：

`f(n) = f(n-1) + f(n-2);`

递推而出，可以得到：

`f(n) = [f(n-2) + f(n-3)] + [f(n-3) + f(n-4)]`

一直拆分下去，最后一次会拆分为：`f(3) = f(2) + f(1)`进而无法拆分，而`f(1)`与`f(2)`需要我们自己计算给出，从而向上回推得出`f(n)`。类似于斐波那契数列，也需要我们给出前两项，才能根据规则计算出后来的项。



### 方法一：递归

根据问题分析中的拆解过程，我们可以写出下列递归解法：

```C++
int climbStairs(int n)
{
    if(n == 1)
        return 1;
    else if(n == 2)
        return 2;
    else
        return climbStairs(n-1) + climbStairs(n-2);
}
```

可以根据判断条件进一步精简为：

```C++
int climbStairs(int n)
{
    if(n == 1 || n == 2)
        return n;
    else
        return climbStairs(n-1) + climbStairs(n-2);
}
```

递归解法虽然正确，但是时间复杂度最高，很大可能超时，需要优化。当输入n为36时，提交超时！



### 方法二：迭代法

> 类似斐波那契数列，根据前两项递推第三项

依然利用`f(n) = f(n-1) + f(n-2)`，但是是**自底向上**（即利用数列思想：1,2,3,5,8...）递推，而不是自顶向下分解，实现方式如下：

```C++
int climbStairs(int n)
{
    if(n == 1 || n == 2)
        return n;
    int f1 = 1;
    int f2 = 2;
    for(int i = 3; i <= n; i++)
    {
        int tmp = f2;
        f2 += f1;
        f1 = tmp;
    }
    return f2;
}
```

提交结果：

<img src="https://raw.githubusercontent.com/huibazdy/TyporaPicture/main/202208031128298.png" alt="image-20220803112801260" style="zoom: 67%;" />



### 方法三：动态规划

> 不需要列出方案，但需要计算有多少种方案的，一般都可以利用动态规划来解决。

* DP**转移方程**：`f(n) = f(n-1) + f(n-2) `
* DP**边界条件**：



2024-01-05

* **子问题**

    爬上最后一阶台阶的情况只有两种：

    1. 第一种：在爬上第 n-1 级台阶后再爬 1 个台阶；
    2. 第二种：在爬上第 n-2 级台阶后再爬 2 个台阶

    假设爬上第 n-1 级台阶有`f(n-1)`种方法，爬上第 n-2 级台阶有`f(n-2)`种方法。很自然地，爬上第 n 阶台阶的方法数就是这两种状态下的方法之和：
    $$
    f(n)\:=\:f(n-1)\:+\:f(n-2)
    $$

* **状态转移方程**

    状态转移如上

* **构造 dp 数组**

    用一个长度为 n 的 dp 数组来表示爬上第 n 阶台阶的方式总数:

    1. 初始化：dp[1] = 1；dp[2] = 2；（dp[0]无实际意义，默认初始化为 0 即可）
    2. 遍历顺序：因为 dp[n] 取决于 dp[n-1] 和 dp[n-2]，所以从左至右

    最后求出的 dp[n] 即为所求

    ```c++
    std::vector<int> dp(n+1);
    dp[1] = 1;  
    dp[2] = 2;
    for(int i = 3; i < n; i++){
        dp[i] = dp[i-1] + dp[i-2];
    }





```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n == 1)   //因为 n 可等于 1，而后又有dp[2] 赋值会导致溢出
            return n;
        std::vector<int> dp(n+1);
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i < n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```







### 小结

此问题可以参考斐波那契数列的优化方法。