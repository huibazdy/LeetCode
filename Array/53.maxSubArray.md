# 53.maxSubArray

给定一个整数数组（长度不为 0），找出具有最大和的连续子数组，返回其最大和

![image-20240103154238855](https://raw.githubusercontent.com/huibazdy/TyporaPicture/main/image-20240103154238855.png)



> **构造前缀和数组，降低任意子数组求和复杂度**

```c++
std::vector<int> preSum;
int sum = 0;
for(int i = 0; i < nums.size(); i++) {
    sum += nums[i];
    preSum.emplace_back(sum);
}
```

这样任意子数组（`[i,j]`，此处 i 大于 0）的求和就可以表示为`preSum[j] - preSum[i-1]`。



> 双指针来“夹”出最大值

```c++
int n = nums.size();
int le = 0; 
int ri = n - 1;
int max = preSum[ri];
while(le != ri){
    if((preSum[ri-1]-preSum[le-1]) <= max){  // 左移右指针，发现子数组和未增大
        ri--;
    }
    else if((preSum[ri]-preSum[le+1]) <= max){ // 右移左指针，发现子数组和未增大
        le++;
    }
    else if((preSum[ri-1]-preSum[le-1]) > max){
        max = max(max,preSum[ri-1]-preSum[le-1]);
        ri--;
    }
    else if((preSum[ri]-preSum[le+1]) > max){
        max = max(max,preSum[ri]-preSum[le+1]);
    }
}
return max;
```



```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
		
    }
};
```