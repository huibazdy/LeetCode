# 560.subarraySum

> 给定一个整数数组和一个整数 k ，统计并返回该数组中和为 k 的子数组（连续非空序列）个数

![image-20231227200154028](https://raw.githubusercontent.com/huibazdy/TyporaPicture/main/image-20231227200154028.png)



> 思路一：暴力 + 滑动窗口

1. 子数组长度可能是 ：1，2，3，...， n，其中 n 是数组长度
2. 以每一个子数组长度为滑动窗口，遍历整个数组（遍历次数随着窗口增大而减少）



```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
		int res = 0;
        int n = nums.size();
        if(n == 1) {
            if(k == nums[0])
                return 1;
            return 0;
        }
        for(int len = 2; len <= n; len++) {  // 不断改变窗口长度 len
            int l = 0;           // 窗口左指针
            int r = l + len -1;  // 窗口右指针
            while(l < n && r < n) {  // 窗口开始遍历数组
                int sumSubArray = 0;
                for(int i = l; i <= r; i++)  // 子数组求和
                    sumSubArray += nums[i];
                if(sumSubArray == k)   // 判断是否和为 k
                    res++;
            }
        }
        return res;
    }
};
```

测试结果：超出时间限制



> 前缀和

前缀和就是前 i 个元素的和。

将前缀和保存到一个数组 `preSum[]` 中，这样一来，求取任意子数组（ `[i,j]`）和的问题就转化为了求取：`preSum[j] - preSum[i-1]`。这样做的好处是求子数组的和的时间复杂度达到：$O(1)$ 。



另一方面，我们只关心满足条件的出现次数，不关心具体的解，可以使用哈希表来加速。哈希表的健为：`preSum[i]`，值为该前缀和数组中出现的次数。



有点类似两数之和这个题，此时 target 就是 k ，此时只需要统计 `preSum[i-1] = preSum[j] - k`的出现次数即可。



综上，解题步骤如下：

1. 计算获得前缀和数组：`preSum[]`
2. 申请一个哈希表（`std::unordered_map<int,int> hash`）用来统计各个前缀和的出现次数
3. 如果`preSum[j] - k`在 hash 中，返回值（`res`）加上`hash[preSum[j] - k]`（出现次数）
4. 如果 `preSum[i]` 在哈希表中，那么 `hash[preSum[i]]`（出现次数）加 1
5. 最后输出返回值。



```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int res = 0;
        int n = nums.size();
        vector<int> preSum;   // 前缀和数组
        int sum = 0;
        for(int i = 0; i < n; i++){  // 计算 n 个前缀和并加入前缀和数组
            sum += nums[i];
            preSum.push_back(sum);
        }
        
        unordered_map<int,int> hash;
        for(int i = 0; i < n; i++){  // 将前缀和数组记录到 hash 中
            if(hash.find(preSum[i]) == hash.end()) {
                hash.insert(make_pair(preSum[i],1));
            }
            else {
                hash[preSum[i]]++;
            }
        }
        
        for(int i = 0; i < n; i++){
            if(hash.find() != hash.end())
        }
    }
};
```