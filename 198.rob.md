# 198.rob

打家劫舍：不能偷相邻房屋，要求偷得金额最大。



> **动态规划四部曲**

## 步骤一：定义子问题

与原问题类似，但规模更小的问题。

例如：此题中的问题是从 ***`n`*** 个房子中能偷到的最大金额 ***`f(n)`***，子问题可以理解为从前 ***`k`*** 个房子中偷盗的最大金额，用 ***`f(k)`*** 表示。



可以看出子问题有如下特点：

1. 参数化
2. 规模为 **n** 的问题可以分解为 **n** 个子问题，也就是 ***`k = {1,2,3...n}`***情况下分别求取的***`f(1)`***到***`f(n)`***。



> **子问题需要满足的性质**

1. **原问题能用子问题表示**

    如当 ***`k = n`*** 时，子问题 ***`f(k)`*** 就是原问题。 

2. **子问题的解能由其他子问题求出**

    这个性质就是教材中说的最优子结构。若该问题定义不出这样的子问题，则无法用动态规划解决。



## 步骤二：写出子问题的递推关系

该步骤时 DP 问题的核心步骤。

在代码中很难体现出来，做题时最好用笔将思路写下来。

前 k 个房子的最大金额偷法有两种，分别为偷没偷第 k 个房子，如果偷了（设该房子中金额为 **M<sub>k</sub>**），可以根据偷而不被发现的规则得出第 k-1 个房子肯定没偷，且前 k-2 个房子也偷到了最大金额即：**f(k-2)** ，此种偷法的总金额为：**M<sub>k</sub>** + **f(k-2)** 。另一种情况是没有偷第 k 个房子，那问题就退化为了前 k-1 个房子的最大金额：**f(k-1)** 。所以最后能偷到的 f(k) 的最大值应该是：
$$
f(k) = max\{f(k-1),\ M_k\,+\,f(k-2)\}
$$
也可以写成以下形式（大括号）：

除此以外，还要加上初始条件，这样整个递推关系才是完整的。

* `k = 0`，没有房子，所以 `f(0) = 0`
* `k = 1`，只有一个房子可以偷，故 `f(1) = M1`



## 步骤三：确定 DP 数组的计算顺序

> ***DP 数组***

**DP 数组**又叫子问题数组，因为 DP 数组的每一个元素对应一个子问题，例如：`dp[k]` 对应子问题 ***`f(k)`***。



只要搞清楚了子问题的计算顺序，就可以确定 DP 数组的计算顺序。在打家劫舍问题中，每个子问题***`f(k)`*** 都依赖于前两个子问题：***`f(k-1)`***和***`f(k)`***。



也就是说：`dp[k]` 依赖于 `dp[k-1]` 以及 `dp[k-2]`。所以可以得出 DP 数组的计算顺序是从左向右。 



截止目前可以写出以下代码：

```c++
int rob(vector<int>& nums)
{
	if(nums.size() == 0)
        return 0;
    
    // 初始条件：f(0) = 0，f(1) = nums[0]
    vector<int> dp(10);
    dp[0] = 0;
    dp[1] = nums[0];
    for(int k = 2; k < nums.size(); k++) //剩余子问题
    {
        dp[k] = max(dp[k-1],nums[k-1]+dp[k-2]);
    }
    return dp[nums.size()];
}
```

执行结果：

![image-20230821160005896](https://raw.githubusercontent.com/huibazdy/TyporaPicture/main/image-20230821160005896.png)

在运行比较长的测试用例时，会超出空间限制。这是由于计算了过多的重复项导致。需要进一步优化，类似斐波那契数列。



## 步骤四：空间优化





> **几个关于动态规划的问题**

1. 自顶向下和自底向上
2. 一维和二维动态规划
3. 带备忘录与循环数组