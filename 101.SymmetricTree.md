需要明确的是，对称的核心是左右子树互为镜像，比较的不是左右节点。

左右子树互为镜像的判断方法是：外侧节点、内侧节点是否分别相等。

【**遍历**】

对两颗子树的遍历顺序，左子树应该是：“左右根”，右子树应该是“右左根”。

【**递归**】

递归三部曲：

1. 确定递归函数的参数和返回值；
2. 确定终止条件；
3. 确定单层递归逻辑



1. 参数肯定是左右子树对应需要比较的两个节点，返回值是bool类型，确定对应节点的 val 是否相等

    ```c++
    bool compareTraversal(TreeNode* left,TreeNode* right);
    ```

2. 终止条件

    什么时候应该终止遍历，首先应该想到节点为空。节点是否为空有以下几种情况：

    * 左子树节点空，右子树节点非空，不对称，返回 false
    * 右子树节点空，左子树节点非空，不对称，返回 false
    * 左右子树节点都为空，返回 true

    其次，当左子树与右子树对应节点值不相等的情况，返回 false

    综上所述，判断终止的代码应该如下：

    ```c++
    if(left == nullptr && right!= nullptr)
        return false;
    else if(right == nullptr && left != nullptr)
        return false;
    else if(left ==nullptr && right == nullptr)
        return true;
    else if(left->val != right->val)
        return false;
    ```

    剩下的情况就是左右子树对应的节点都不为空且 val 相同的情况。

3. 单层递归逻辑，逐层处理左右子树对应节点不为空且 val 相同的情况。

    * 比较左子树的左节点与右子树的右节点

        ```c++
        bool outside = compareTraversal(left->left,rigth->right);
        ```

    * 比较左子树的右节点与右子树的左节点

        ```c++
        bool inside = compareTraversal(left->right,rigth->left);
        ```

    * 确认条件，两次比较是否都满足条件

        ```c++
        bool isSame = false;
        isSame = outside && inside;
        ```



```c++
bool compareTraversal(TreeNode* left,TreeNode* right)
{
    if(left == nullptr && right!= nullptr)
    	return false;
	else if(right == nullptr && left != nullptr)
    	return false;
	else if(left ==nullptr && right == nullptr)
    	return true;
	else if(left->val != right->val)
    	return false;
    
    bool outside = compareTraversal(left->left,rigth->right);
    bool inside = compareTraversal(left->right,rigth->left);
    bool isSame = isSame = outside && inside;

    return isSame;
}

bool isSymmetric(TreeNode* root)
{
    if(root == nullptr)
        return true;
    return compareTraversal(root);
}
```

