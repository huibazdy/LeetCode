# 31.nextPermutation

要求原地，只能使用常数额外空间。



下一个排列总比当前排列大，除非当前排列已是最大（降序排列）。



三步走：

1. 找出分界点，从尾到头首次出现不是升序的位置 `i`，此时导致出现降序的值是：`nums[i-1]`；
2. 在尾部已经确定是升序的区间（`i`到`nums.size()-1`）内找到首次大于`nums[i-1]`的值并记录其位置`j`
3. 交换，`nums[i-1]`与`nums[j]`；
4. 使区间`i`到`nums.size()-1`重新变为降序，使用reverse算法。



```c++
void nextPermutation(vector<int>& nums)
{
    
}
```