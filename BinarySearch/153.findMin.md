# 153.寻找旋转排序数组中的最小值

> **旋转**

旋转数组就是从数组尾部依次“弹出”元素再“插入”数组头部，形成“循环”的效果，例：
原数组：    `[0,1,2,4,5,6,7]`
旋转 1 次：`[7,0,1,2,4,5,6]`
旋转 4 次：`[4,5,6,7,0,1,2]`
旋转 7 次：`[0,1,2,4,5,6,7]`



> **题目**

升序数组（元素值互不相同）经过 1~n 次旋转后得到输入数组，找出输入数组中最小元素，要求：**`O(log n)`**



> **思路**

因为题目涉及到有序数组以及复杂度为对数级别，所以想到使用二分法。由于原数组存在旋转，故使用**`mid`**分割输入数组时，一定会将数组分割为有序和无序两个部分，且只可能是后半部分有序。而且最小值一定是有序部分的起始元素。所以，最终题目就转化为了寻找有序区间的首元素。

1. 如果存在旋转，且旋转次数不为 n，那么最小元素一定在中间出现无序的某处
2. 



> **代码**

```c++
int findMin(vector<int>& nums)
{
    int n = nums.size();
    if(n == 1)
        return nums[0];
    int left = 0, right = n - 1;
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(nums[left] <= nums[mid] && left ) {           // [left,mid] 有序
            left = mid;  // 无序点只可能出现在 (mid,right] 中间，故更新二分搜索区间为后半部
        }
        else {                                 // [left,mid] 无序
            if((mid -left) == 1)  // 已经找到无序点为 nums[mid]
                return nums[mid];
            else
                right = mid;  // 无序点只可能出现在 [left,mid] 中间，故更新二分搜索区间为前半部
        }                           
    }
    return nums[0]; // 旋转过 n 次
}
```