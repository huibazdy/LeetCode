# 34.searchRange

【tags】

* 二分查找



> 题目描述

非递减排序数组 nums 以及一个 target ，找出给定 target 在数组中的开始位置和结束位置，如果数组中不存在 target 则返回 `[-1,-1]`。必须设计时间复杂度为 `O(logn)`算法。示例如下：
<img src="https://raw.githubusercontent.com/huibazdy/TyporaPicture/main/image-20240522115249331.png" alt="image-20240522115249331" style="zoom: 42%;" />



> 二分查找

因为是已排序数组，且要求实现 logn 级别的算法，故考虑用二分查找。



> 写一个小的函数模块，用于找到 target 存在的区间左边界（记为`startIndex`）

查找左边界

```c++
// 边界条件：
// target 不存在，返回 nums.size()
int BinarySearch(vector<int>& nums,int target)
{
    int left = 0;
    int right = nums.size() -1;
    while(left <= right) {  // 搜索区间不能为空
        int mid = left + (right - left) / 2;
        if(nums[mid] < target)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return left;  // 返回 left 或 right 都可以，因为循环退出条件是二者重合
}
```

注意，如果数组中最后一个元素都小于target，此时 left 为 `nums.size()`，因为最后加了 1 而退出循环。数组首元素都小于target，那么最后 right 为 -1 ，退出循环。

主函数

```c++
vector<int> searchRange(vector<int>& nums, int target)
{
    int n = nums.size();
    if(n == 0 || nums[0] > target || nums[n-1] < target)
        return {-1,-1};
    int startIndex = BinarySearch(nums,target);
    int endIndex = BinarySerch(nums,target+1) - 1;
    return {startIndex,endIndex};
}
```

