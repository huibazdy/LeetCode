# 49.trapRain

给定 n 个非负整数，表示 n 个 宽度为 1 的柱子，计算按此排列的柱子下雨后能接多少雨水。

![image-20231221161901778](https://raw.githubusercontent.com/huibazdy/TyporaPicture/main/image-20231221161901778.png)

通过读题和图像，可以得出我们需要找一种“模式”：两边高中间低。利用双指针，一个指针 s 记录左边柱子，第二个指针 f从下一个柱子开始，移动 f 直到找到第一个高度不小于 s 的柱子（注意，在移动过程中直接就将覆盖到的雨水体积计算出来）。

之后移动 s 到 f 位置，更新 f 位置为 s 下一个位置，继续上述步骤，直到 f 达到数组边界。



> **没有加最大值判断，会导致多加**

输入：[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
实际输出：11
期望输出： 6





```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int res = 0;
        int n = height.size();
        if(n == 1 || n == 2)
            return res;
		int s = 0, f = 1;  // 快慢指针
        int maxElem = *max_element(height.begin(),height.end());  // 找到最大元素
        while(f < n) {
            if(height[f] < height[s] && height[s] != maxElem && (f != n-1)) {// 不能是剩下部分的最大值
                res += (height[s] - height[f++]) * 1;
            }
            else {
                s = f;
                f = s + 1;
            }
        }
        return res;
    }
};
```

输入：[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
实际输出：7
期望输出：6



> 处理右边界，不应该多加 1





```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int res = 0;
        int n = height.size();
        if(n == 1 || n == 2)
            return res;
		int s = 0, f = 1;  // 快慢指针
        int maxElem = *max_element(height.begin(),height.end());  // 找到最大元素
        while(f < n) {
            if(height[s] > height[f] && f != (n-1) {
                res += height[s] - height[f++];
            }
            s = f;
            f = s + 1;
        }
        return res;
    }
};
```