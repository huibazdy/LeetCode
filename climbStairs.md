## 爬楼梯（T70）

### 问题描述

**n**阶台阶，每次爬1级或2级，有多少种爬法？



### 问题解读

假设解决问题的函数是`f()`，输入楼梯数`n`，即可得到爬楼梯方案数答案：`f(n)`。

一个事实是完成爬完n阶台阶的前一个状态有两种：

1）最后一次采取爬1阶：即此前爬了n-1阶，这n-1阶又有`f(n-1)`种爬法

2）最后一次采取爬2阶：即此前爬了n-2阶，这n-2阶又有`f(n-2)`种爬法

综上可以得出一个事实是：爬完n阶的总方法数可以根据最后一次爬楼梯的阶数理解为两部分相加而成。根据之前的函数假设，可以表达为下列式子：

`f(n) = f(n-1) + f(n-2);`

递推而出，可以得到：

`f(n) = [f(n-2) + f(n-3)] + [f(n-3) + f(n-4)]`

一直拆分下去，最后一次会拆分为：`f(3) = f(2) + f(1)`进而无法拆分，而`f(1)`与`f(2)`需要我们自己计算给出，从而向上回推得出`f(n)`。类似于斐波那契数列，也需要我们给出前两项，才能根据规则计算出后来的项。



### 方法一：递归

根据问题分析中的拆解过程，我们可以写出下列递归解法：

```C++
int climbStairs(int n)
{
    if(n == 1)
        return 1;
    else if(n == 2)
        return 2;
    else
        return climbStairs(n-1) + climbStairs(n-2);
}
```

可以根据判断条件进一步精简为：

```C++
int climbStairs(int n)
{
    if(n == 1 || n == 2)
        return n;
    else
        return climbStairs(n-1) + climbStairs(n-2);
}
```

递归解法虽然正确，但是时间复杂度最高，很大可能超时，需要优化。当输入n为36时，提交超时！



### 方法二：动态规划









### 小结

此问题可以参考斐波那契数列的优化方法。